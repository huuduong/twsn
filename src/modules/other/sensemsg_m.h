//
// Generated file, do not edit! Created by opp_msgc 4.3 from modules/other/sensemsg.msg.
//

#ifndef _SENSEMSG_M_H_
#define _SENSEMSG_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0403
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include "measurement.h"
// }}


namespace twsn {

// cplusplus {{
typedef std::list<Measurement> MeasurementList;
// }}

/**
 * Enum generated from <tt>modules/other/sensemsg.msg</tt> by opp_msgc.
 * <pre>
 * enum SenseMsgType {
 *     SS_START = 0; 
 *     SS_CANCEL = 1; 
 *     SS_RESULT = 2; 
 *     SS_ACTION = 3; 
 *     SS_SIGNAL = 4; 
 * };
 * </pre>
 */
enum SenseMsgType {
    SS_START = 0,
    SS_CANCEL = 1,
    SS_RESULT = 2,
    SS_ACTION = 3,
    SS_SIGNAL = 4
};

/**
 * Class generated from <tt>modules/other/sensemsg.msg</tt> by opp_msgc.
 * <pre>
 * message SenseMsg {
 *     int msgType;
 * }
 * </pre>
 */
class SenseMsg : public ::cMessage
{
  protected:
    int msgType_var;

  private:
    void copy(const SenseMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SenseMsg&);

  public:
    SenseMsg(const char *name=NULL, int kind=0);
    SenseMsg(const SenseMsg& other);
    virtual ~SenseMsg();
    SenseMsg& operator=(const SenseMsg& other);
    virtual SenseMsg *dup() const {return new SenseMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getMsgType() const;
    virtual void setMsgType(int msgType);
};

inline void doPacking(cCommBuffer *b, SenseMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SenseMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>modules/other/sensemsg.msg</tt> by opp_msgc.
 * <pre>
 * message SenseResult extends SenseMsg {
 *     msgType = SS_RESULT;
 *     MeasurementList meaList; 
 * }
 * </pre>
 */
class SenseResult : public ::twsn::SenseMsg
{
  protected:
    twsn::MeasurementList meaList_var;

  private:
    void copy(const SenseResult& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SenseResult&);

  public:
    SenseResult(const char *name=NULL, int kind=0);
    SenseResult(const SenseResult& other);
    virtual ~SenseResult();
    SenseResult& operator=(const SenseResult& other);
    virtual SenseResult *dup() const {return new SenseResult(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual twsn::MeasurementList& getMeaList();
    virtual const twsn::MeasurementList& getMeaList() const {return const_cast<SenseResult*>(this)->getMeaList();}
    virtual void setMeaList(const twsn::MeasurementList& meaList);
};

inline void doPacking(cCommBuffer *b, SenseResult& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SenseResult& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>modules/other/sensemsg.msg</tt> by opp_msgc.
 * <pre>
 * message SenseAction extends SenseMsg {
 *     msgType = SS_ACTION;
 *     int sensorId; 
 *     int mobilityId; 
 * }
 * </pre>
 */
class SenseAction : public ::twsn::SenseMsg
{
  protected:
    int sensorId_var;
    int mobilityId_var;

  private:
    void copy(const SenseAction& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SenseAction&);

  public:
    SenseAction(const char *name=NULL, int kind=0);
    SenseAction(const SenseAction& other);
    virtual ~SenseAction();
    SenseAction& operator=(const SenseAction& other);
    virtual SenseAction *dup() const {return new SenseAction(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSensorId() const;
    virtual void setSensorId(int sensorId);
    virtual int getMobilityId() const;
    virtual void setMobilityId(int mobilityId);
};

inline void doPacking(cCommBuffer *b, SenseAction& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SenseAction& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>modules/other/sensemsg.msg</tt> by opp_msgc.
 * <pre>
 * message SenseSignal extends SenseMsg {
 *     msgType = SS_SIGNAL;
 *     
 *     int tarId; 
 *     
 *     double distance; 
 *     double x; 
 *     double y; 
 * }
 * </pre>
 */
class SenseSignal : public ::twsn::SenseMsg
{
  protected:
    int tarId_var;
    double distance_var;
    double x_var;
    double y_var;

  private:
    void copy(const SenseSignal& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SenseSignal&);

  public:
    SenseSignal(const char *name=NULL, int kind=0);
    SenseSignal(const SenseSignal& other);
    virtual ~SenseSignal();
    SenseSignal& operator=(const SenseSignal& other);
    virtual SenseSignal *dup() const {return new SenseSignal(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getTarId() const;
    virtual void setTarId(int tarId);
    virtual double getDistance() const;
    virtual void setDistance(double distance);
    virtual double getX() const;
    virtual void setX(double x);
    virtual double getY() const;
    virtual void setY(double y);
};

inline void doPacking(cCommBuffer *b, SenseSignal& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SenseSignal& obj) {obj.parsimUnpack(b);}

}; // end namespace twsn

#endif // _SENSEMSG_M_H_
